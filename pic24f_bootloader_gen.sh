#!/bin/bash

if [ -z $1 ]; then
	echo "usage: $0 [device_name]"
	exit 1
fi

DEVICE=$1
OUTPUT=output/${DEVICE}-bootloader.gld

cat >$OUTPUT << ENDHEADER
/************************************************
 Linker script for $DEVICE

 Generated by the Signal 11 Software
 PIC24F Linker Script Generator

 http://github.com/signal11/pic_linker_script

 This script may be used by anyone for any
 purpose and may be redistributed freely.
************************************************/
ENDHEADER


cat ${DEVICE}_mem.txt >> $OUTPUT
echo "" >> $OUTPUT

cat pic24f_mem_bootloader.txt >> $OUTPUT
echo "" >> $OUTPUT


echo "" >> $OUTPUT
echo "#ifdef BOOTLOADER" >> $OUTPUT
echo "/* Alternate interrupt handlers are not mapped into the application */" >> $OUTPUT
echo "#define ALTHANDLER(X) LONG(DEFINED(__Alt##X)? ABSOLUTE(__Alt##X): DEFINED(__##X) ? ABSOLUTE(__##X) : ABSOLUTE(__DefaultInterrupt));"  >> $OUTPUT
echo "#endif" >> $OUTPUT
echo "" >> $OUTPUT

echo "#define INTERRUPT_LIST() \\" >> $OUTPUT

cat pic24f_interrupts.txt | while read INTERRUPT IMPLEMENTED
do
	if [ $INTERRUPT ]; then
		if [ $IMPLEMENTED == "Y" ]; then
			echo -e  "\t\tINTERRUPT($INTERRUPT) \\" >> $OUTPUT
		else
			echo -e  "\t\tUNUSED_INTERRUPT($INTERRUPT) \\" >> $OUTPUT
		fi
	fi

done
echo -e "\t\t/* End macro (the comment gives it a last line without a \\) */" >> $OUTPUT
echo "" >> $OUTPUT
echo "" >> $OUTPUT



echo "SECTIONS {" >> $OUTPUT

echo "#ifdef BOOTLOADER" >> $OUTPUT
cat pic24f_reset.txt  >> $OUTPUT
echo "#endif" >> $OUTPUT

echo "" >> $OUTPUT

cat pic24f_icd.txt >> $OUTPUT

echo "" >> $OUTPUT

cat pic24f_debug.txt >> $OUTPUT

echo "" >> $OUTPUT

cat pic24f_configs.txt >> $OUTPUT

echo "" >> $OUTPUT

echo "#ifdef BOOTLOADER" >> $OUTPUT
echo "/* This macro reserves space for each entry in the interrupt map. Its" >> $OUTPUT
echo "   job is to create a _ADDR variable for the address where the GOTO" >> $OUTPUT
echo "   instruction for each interrupt function will go. Only" >> $OUTPUT
echo "   implemented interrupts are mapped. The application will put the" >> $OUTPUT
echo "   actual mappings in this space, but the bootloader needs to know" >> $OUTPUT
echo "   where each one is so it can put the correct addresses in the IVT. */" >> $OUTPUT
echo "#define INTERRUPT(X) X##_ADDR = .; . += 4;" >> $OUTPUT
echo "#define UNUSED_INTERRUPT(X)" >> $OUTPUT
echo "" >> $OUTPUT

echo -e "\t.ivt_map IVT_MAP_BASE : {" >> $OUTPUT
echo -e "\t\t. += 4; /* This is where the reset/start instruction will go. */" >> $OUTPUT
echo -e "\t\tINTERRUPT_LIST()" >> $OUTPUT
echo -e "\t} >ivt_map" >> $OUTPUT
echo "#endif" >> $OUTPUT

echo "" >> $OUTPUT
echo "#undef INTERRUPT" >> $OUTPUT
echo "#undef UNUSED_INTERRUPT" >> $OUTPUT
echo "" >> $OUTPUT

echo "#ifdef BOOTLOADER" >> $OUTPUT
echo "/* This macro is the interrupt handler addresses that go into the IVT." >> $OUTPUT
echo "   Point the interrupt handler addresses to the addresses in the" >> $OUTPUT
echo "   interrupt map, created above. Only acutal implemented interrupts" >> $OUTPUT
echo "   (implemented at the platform level) are mapped. */" >> $OUTPUT
echo "#define INTERRUPT(X) LONG(DEFINED(X##_ADDR)? ABSOLUTE(X##_ADDR): ABSOLUTE(__DefaultInterrupt));" >> $OUTPUT
echo "#define UNUSED_INTERRUPT(X) LONG(ABSOLUTE(__DefaultInterrupt));" >> $OUTPUT
echo "" >> $OUTPUT

echo -e "\t.intvec IVT_BASE : {" >> $OUTPUT
echo -e "\t\tINTERRUPT_LIST()" >> $OUTPUT
echo -e "\t} >ivt" >> $OUTPUT

echo "" >> $OUTPUT
echo "#undef INTERRUPT" >> $OUTPUT
echo "#undef UNUSED_INTERRUPT" >> $OUTPUT
echo "" >> $OUTPUT
echo "" >> $OUTPUT

echo "/* Altertate Interrupt Table (ALT IVT) */" >> $OUTPUT
echo -e "#define INTERRUPT(X) ALTHANDLER(X)" >> $OUTPUT
echo -e "#define UNUSED_INTERRUPT(X) ALTHANDLER(X)" >> $OUTPUT
echo "" >> $OUTPUT

echo -e "\t.altintvec ALT_IVT_BASE : {" >> $OUTPUT
echo -e "\t\tINTERRUPT_LIST()" >> $OUTPUT
echo -e "\t} >aivt" >> $OUTPUT
echo "#endif /* BOOTLOADER */" >> $OUTPUT

echo "" >> $OUTPUT
echo "#undef INTERRUPT" >> $OUTPUT
echo "#undef UNUSED_INTERRUPT" >> $OUTPUT
echo "" >> $OUTPUT

echo "" >> $OUTPUT
echo "" >> $OUTPUT
echo "#ifdef BOOTLOADER_APP" >> $OUTPUT
echo "/* This macro is the Interrupt MAP. The application puts a GOTO" >> $OUTPUT
echo "   instruction in each space in the map which jumps to the interrupt" >> $OUTPUT
echo "   handler in the application. Note that it takes four words (8 bytes) for each" >> $OUTPUT
echo "   goto instruction which is longer than what is stored in the IVT" >> $OUTPUT
echo "   which is just the address (and not a GOTO instruction). The first" >> $OUTPUT
echo "   slot is special and has a GOTO to the __reset function in libc. This" >> $OUTPUT
echo "   way the bootloader just jumps to the beginning of the interrupt map" >> $OUTPUT
echo "   to start the application */" >> $OUTPUT
echo "#define INTERRUPT(X) LONG(DEFINED(__##X)? (0x040000 | ABSOLUTE(__##X)) : 0x040000 | ABSOLUTE(__DefaultInterrupt)); \\" >> $OUTPUT
echo "                     LONG(DEFINED(__##X)? (ABSOLUTE(__##X) >> 16) & 0x7f : (ABSOLUTE(__DefaultInterrupt) >> 16) & 0x7f);" >> $OUTPUT
echo "#define UNUSED_INTERRUPT(X)" >> $OUTPUT
echo "" >> $OUTPUT

echo -e "\t.ivt_map IVT_MAP_BASE : {" >> $OUTPUT
echo -e "\t\tLONG(0x040000 | ABSOLUTE(__reset) & 0xffff);" >> $OUTPUT
echo -e "\t\tLONG((ABSOLUTE(__reset) >> 16) & 0x7f);" >> $OUTPUT
echo -e "\t\tINTERRUPT_LIST()" >> $OUTPUT
echo -e "\t} >ivt_map" >> $OUTPUT
echo "" >> $OUTPUT
echo "#undef INTERRUPT" >> $OUTPUT
echo "#undef UNUSED_INTERRUPT" >> $OUTPUT
echo "" >> $OUTPUT

echo "#endif" >> $OUTPUT

echo "}" >> $OUTPUT # SECTIONS

echo "" >> $OUTPUT

cat ${DEVICE}_regs.txt | while read REG ADDR
do

	if [ $REG ]; then
		echo -e "$REG = 0x$ADDR;" >> $OUTPUT
		echo -e "_$REG = 0x$ADDR;" >> $OUTPUT
		echo -e "_${REG}bits = 0x$ADDR;" >> $OUTPUT
	fi
done



echo "" >> $OUTPUT

